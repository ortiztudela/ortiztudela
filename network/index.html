<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BIKE Network</title>
  <style>
    html, body { margin:0; height:100%; background:#0f172a; color:#e2e8f0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; }
    .app { display:grid; grid-template-columns:300px 1fr; grid-template-rows:auto 1fr; grid-template-areas:"header header" "sidebar main"; height:100dvh; }
    header { grid-area:header; padding:12px 16px; border-bottom:1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    header h1 { font-size:18px; margin:0; font-weight:600; letter-spacing:.2px; }
    .controls { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .controls input, .controls select, .controls button {
      background:#111827; color:#e5e7eb; border:1px solid #374151; border-radius:6px; padding:6px 10px; font-size:12px;
    }
    .sidebar { grid-area:sidebar; border-right:1px solid #1f2937; padding:12px; overflow:auto; }
    .legend { display:grid; gap:6px; margin-bottom:14px; }
    .legend-item { display:flex; align-items:center; gap:8px; font-size:13px; }
    .legend-swatch { width:12px; height:12px; border-radius:50%; border:2px solid #1f2937; box-shadow:0 0 0 1px #000 inset; }
    .legend-edge { width:24px; height:2px; background:#94a3b8; border-radius:2px; }
    .legend-edge.co { background:#fbbf24; }
    .legend-edge.colab { background: #8b5cf6; height: 2px;}
    .details { background:#0b1328; border:1px solid #1f2937; border-radius:8px; padding:10px; font-size:13px; max-height: calc(100vh - 160px); overflow-y: auto; }
    .details h2 { margin:0 0 8px 0; font-size:14px; font-weight:600; }
    .details p { margin:0 0 6px 0; color:#cbd5e1; line-height:1.45; }
    main { grid-area:main; position:relative; }
    svg { width:100%; height:100%; background: radial-gradient(1000px 800px at 30% 20%, #0b1225 0, #0f172a 40%, #0f172a 100%); cursor:move; }
    .link { stroke:#94a3b8; stroke-opacity:.6; }
    .link.co { stroke:#fbbf24; stroke-dasharray:4 3; stroke-opacity:.9; }
    .link.colab {stroke: #8b5cf6; stroke-dasharray: 2 4; stroke-opacity: 0.9;}
    .node circle { stroke:#0b1225; stroke-width:2px; }
    .node text { font-size:11px; pointer-events:none; fill:#e2e8f0; text-shadow:0 1px 0 rgba(0,0,0,.6); }
    .node:hover circle { filter: drop-shadow(0 0 6px rgba(255,255,255,.3)); }
    .highlight .link { stroke-opacity:.1; }
    .highlight .node circle { opacity:.25; }
    .highlight .node.active circle, .highlight .node.neighbor circle { opacity:1; }
    .highlight .link.active { stroke-opacity:1; stroke-width:2.5px; }
    .pill { display:inline-block; border:1px solid #374151; padding:2px 6px; border-radius:999px; font-size:11px; color:#cbd5e1; margin-right:6px; margin-bottom:6px; background:#0f1a34; }
    .footer { position:absolute; bottom:8px; right:10px; font-size:11px; color:#94a3b8; background:rgba(2,6,23,.6); padding:4px 6px; border:1px solid #1f2937; border-radius:6px; backdrop-filter: blur(6px); }
    a.small { color:#93c5fd; text-decoration:none; border-bottom:1px dotted #93c5fd; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>BIKE Network</h1>
      <div class="controls">
        <input id="search" type="search" placeholder="Search name…"/>
        <select id="filterRole"><option value="all">All roles</option></select>
        <button id="fit">Fit to view</button>
        <button id="reset">Reset</button>
      </div>
    </header>
    <aside class="sidebar">
      <div class="legend">
        <div class="legend-item"><span class="legend-swatch" style="background:#60a5fa"></span> PI</div>
        <div class="legend-item"><span class="legend-swatch" style="background:#c084fc"></span> Postdoc</div>
        <div class="legend-item"><span class="legend-swatch" style="background:#f472b6"></span> PhD Student</div>
        <div class="legend-item"><span class="legend-swatch" style="background:#34d399"></span> Research Admin Support</div>
        <div class="legend-item"><span class="legend-swatch" style="background:#f59e0b"></span> Research Assistant</div>
        <div class="legend-item"><span class="legend-edge"></span> supervision</div>
        <div class="legend-item"><span class="legend-edge co"></span> co-supervision</div>
        <div class="legend-item"><span class="legend-edge colab"></span> colaboration</div>
      </div>
      <div class="details" id="details">
        <h2>Details</h2>
        <p>Hover to highlight connections. Drag to tidy. Click to pin. Double-click to unpin.</p>
        <p>Data source: <code>team.json</code>. Edit it to update the graph.</p>
      </div>
    </aside>
    <main>
      <svg id="viz" viewBox="0 0 1200 800" preserveAspectRatio="xMidYMid meet"></svg>
      <div class="footer">Built with D3.js. Data from <code>team.json</code>.</div>
    </main>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const roleStyle = {
      pi:        { color:"#60a5fa", r:12, group:"PI" },
      phd_student:   { color:"#f472b6", r:8,  group:"PhD student" },
      postdoc:   { color:"#c084fc", r:9,  group:"Postdoc" },
      research_assistant: { color:"#f59e0b", r:9, group:"Research Assistant" },
      research_support:   { color:"#34d399", r:9, group:"Research Admin Support" }
    };
    const STUDENT_ROLES     = new Set(["postdoc", "phd_student", "masters_student", "undergrad"]);
    const SUPERVISOR_ROLES  = new Set(["supervisor", "supervision", "pi"]); // add more if you invent new labels

    const fallbackStyle = { color:"#94a3b8", r:8, group:"Other" };

    const svg = d3.select("#viz");
    const g = svg.append("g");
    const details = document.getElementById("details");
    const searchInput = document.getElementById("search");
    const filterRole = document.getElementById("filterRole");

    let nodes = [], links = [], neighbors = {}, nodeSel, linkSel, simulation;

    fetch("team.json?cachebust=" + Date.now())
      .then(r => r.json())
      .then(data => initGraph(data))
      .catch(err => {
        console.error("Failed to load team.json", err);
        details.innerHTML = "<h2>Error</h2><p>Couldn't load <code>team.json</code>. Place it next to this HTML.</p>";
      });

    function initGraph(data) {
      nodes = data.nodes;
      links = data.links;

      const roleSet = new Set(nodes.map(n => n.role).filter(Boolean));
      const roles = ["all", ...Array.from(roleSet).sort()];
      filterRole.innerHTML = roles.map(r => r==="all" ? '<option value="all">All roles</option>' : `<option value="${r}">${labelize(r)}</option>`).join("");

      neighbors = buildNeighborMap(nodes, links);

      linkSel = g.append("g")
        .attr("stroke-linecap", "round")
        .selectAll("line")
        .data(links)
        .join("line")
        .attr("class", d => "link" + (d.type ? " " + d.type : ""))
        .attr("stroke-width", d => d.type === "co" ? 2 : 1.5);

      nodeSel = g.append("g")
        .selectAll("g")
        .data(nodes)
        .join("g")
        .attr("class", "node")
        .call(drag(simulation));

      nodeSel.append("circle")
        .attr("r", d => (roleStyle[d.role]?.r ?? fallbackStyle.r))
        .attr("fill", d => (roleStyle[d.role]?.color ?? fallbackStyle.color));

      nodeSel.append("text")
        .attr("x", 12)
        .attr("y", 4)
        .text(d => d.id);

      nodeSel.on("click", (event, d) => { d.fx = d.x; d.fy = d.y; showDetails(d); });
      nodeSel.on("dblclick", (event, d) => { d.fx = null; d.fy = null; showDetails({id:"Details", role:"", description:"Node unpinned."}); });
      nodeSel.on("mouseenter", (event, d) => highlight(d));
      nodeSel.on("mouseleave", () => clearHighlight());

      simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(l => l.type === "co" ? 90 : 70).strength(l => l.type === "co" ? 0.15 : 0.08))
        .force("charge", d3.forceManyBody().strength(-220))
        .force("collide", d3.forceCollide().radius(d => (roleStyle[d.role]?.r ?? 8) + 14).iterations(2))
        .force("center", d3.forceCenter(600, 400))
        .on("tick", ticked);

      const zoom = d3.zoom().scaleExtent([0.25, 3]).on("zoom", (event) => { g.attr("transform", event.transform); });
      svg.call(zoom);

      document.getElementById("fit").addEventListener("click", () => fitToView(zoom));
      document.getElementById("reset").addEventListener("click", () => svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity));
      searchInput.addEventListener("input", applyFilters);
      filterRole.addEventListener("change", applyFilters);

      setTimeout(() => fitToView(zoom), 900);
    }

    function labelize(s){ return (s||"").replace(/_/g," ").replace(/\b\w/g, m => m.toUpperCase()); }

    function ticked() {
      linkSel
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);
      nodeSel.attr("transform", d => `translate(${d.x},${d.y})`);
    }

    function drag(sim) {
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.2).restart();
        d.fx = d.x; d.fy = d.y;
      }
      function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
      function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); }
      return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
    }

    function buildNeighborMap(nodes, links) {
      const map = {};
      nodes.forEach(n => map[n.id] = new Set());
      links.forEach(l => {
        const s = typeof l.source === "object" ? l.source.id : l.source;
        const t = typeof l.target === "object" ? l.target.id : l.target;
        map[s].add(t); map[t].add(s);
      });
      return map;
    }

    function showDetails(d) {
      const roleLabel = d.role ? labelize(d.role) : "";
      const projs = (d.projects||[]).map(p=>`<span class="pill">${p}</span>`).join(" ");
      const fells = (d.fellowships||[]).map(p=>`<span class="pill">${p}</span>`).join(" ");
      const conn = describeConnections(d);

      details.innerHTML = `
      <h2>${d.id}</h2>
      <p>${roleLabel ? `<span class="pill">${roleLabel}</span>` : ""} ${projs} ${fells}</p>
      <p>${conn}</p>
      <p style="opacity:.8">Tip: Edit <code>team.json</code> and refresh.</p>
      ${d.image ? `
        <div style="margin-top:10px;">
          <img src="pics/${d.image}"
               style="width:100%; max-height:300px; object-fit:cover; border-radius:6px;" />
        </div>` : ""}
      ${d.site ? `
        <div style="margin-top:8px; text-align:center;">
          <a href="${d.site}" target="_blank"
             style="display:inline-block; padding:6px 12px; background:#2563eb; opacity:.8; color:#fff; text-decoration:none; border-radius:4px; font-size:13px;">
            Personal Site
          </a>
        </div>` : ""}
    `;
    }

    function describeConnections(d) {
      // Helpers
      const idOf = v => (v && v.id) ? v.id : v;
      const uniq = arr => [...new Set(arr)];
      const isStudent        = (n) => n && STUDENT_ROLES.has(n.role);
      const isSupervisorLike = (n) => n && SUPERVISOR_ROLES.has(n.role);

      // Buckets
      const reportsTo    = [];      // supervisors of d (incoming directed supervision)
      const supervises   = [];      // students d supervises (outgoing directed supervision)
      const coPairs      = [];      // [{student, with:[other supervisors]}] for d
      const collabWith   = [];      // undirected collaborations

      // Index nodes by id for role checks
      const byId = new Map(nodes.map(n => [n.id, n]));

      // Build quick lookup: for each student, list all their supervisors (from both 'supervision' and 'co')
      const studentToSupers = new Map();
      links.forEach(l => {
        const s = idOf(l.source), t = idOf(l.target);
        if ((l.type === "supervision" || l.type === "supervisor" || l.type === "co") && isStudent(byId.get(t))) {
          const arr = studentToSupers.get(t) || [];
          arr.push(s);
          studentToSupers.set(t, arr);
        }
      });

      // Walk edges touching d
      links.forEach(l => {
        const s = idOf(l.source), t = idOf(l.target);

        if (l.type === "colab") {
          if (s === d.id) collabWith.push(t);
          else if (t === d.id) collabWith.push(s);
          return;
        }

        if (l.type === "co") {
          // treat as undirected for "who co-supervises with me" / "who co-supervisors me"
          if (s === d.id && isStudent(byId.get(t)) && studentToSupers.has(t)) {
            const others = uniq(studentToSupers.get(t).filter(x => x !== d.id));
            coPairs.push({ student: t, with: others });
          } else if (t === d.id && isStudent(byId.get(s)) && studentToSupers.has(s)) {
            const others = uniq(studentToSupers.get(s).filter(x => x !== d.id));
            coPairs.push({ student: s, with: others });
          }
          // If d is a student on a 'co' link, their supervisors will be handled in the student clause below.
          return;
        }

        // Directed supervision edges
        if (l.type === "supervision" || l.type === "supervisor") {
          if (t === d.id) reportsTo.push(s);           // someone supervises d
          if (s === d.id && isStudent(byId.get(t))) {  // d supervises this student
            supervises.push(t);
            // For co-supervise display, also compute "with …" (other supervisors of that student)
            const others = uniq((studentToSupers.get(t) || []).filter(x => x !== d.id));
            if (others.length) coPairs.push({ student: t, with: others });
          }
        }
      });

      // Remove duplicates
      const uniqReportsTo  = uniq(reportsTo);
      const uniqSupervises = uniq(supervises);
      const uniqCollab     = uniq(collabWith);

      // Role-aware phrasing
      const parts = [];
      const role = d.role;

      if (isStudent(d)) {
        // Collect supervisors from BOTH supervision and co-supervision edges
        const allSupers = [];
        links.forEach(l => {
          if (l.type === "supervision" || l.type === "supervisor" || l.type === "co") {
            const s = l.source.id ?? l.source;
            const t = l.target.id ?? l.target;
            if (t === d.id) allSupers.push(s);
            if (s === d.id) allSupers.push(t);
          }
        });
        const uniqSupers = uniq(allSupers);
        if (uniqSupers.length === 1) parts.push(`Supervisor: ${uniqSupers[0]}`);
        else if (uniqSupers.length > 1) parts.push(`Supervisors: ${uniqSupers.join(", ")}`);
      }
      else if (isSupervisorLike(d)) {
        if (uniqSupervises.length) {
          parts.push(`Supervises: ${uniqSupervises.join(", ")}`);
        }
        // Merge same student entries (in case we added twice)
        const byStudent = new Map();
        coPairs.forEach(p => {
          const cur = byStudent.get(p.student) || new Set();
          p.with.forEach(w => cur.add(w));
          byStudent.set(p.student, cur);
        });
        const coLines = [];
        byStudent.forEach((withSet, student) => {
          const withArr = [...withSet];
          if (withArr.length) coLines.push(`${student} (with ${withArr.join(", ")})`);
        });
        if (coLines.length) parts.push(`Co-supervises: ${coLines.join("; ")}`);
        if (uniqReportsTo.length) {
          // In case a PI→Supervisor hierarchy exists
          parts.push(`Reports to: ${uniqReportsTo.join(", ")}`);
        }
      } else {
        // Postdoc / RA / support / other
        if (uniqReportsTo.length === 1) parts.push(`Reports to: ${uniqReportsTo[0]}`);
        else if (uniqReportsTo.length > 1) parts.push(`Reports to: ${uniqReportsTo.join(", ")}`);
      }

      if (uniqCollab.length === 1) parts.push(`Collaborates with: ${uniqCollab[0]}`);
      else if (uniqCollab.length > 1) parts.push(`Collaborates with: ${uniqCollab.join(", ")}`);

      return parts.join("<br/>") || "No connections.";
    }



    function highlight(d) {
      svg.classed("highlight", true);
      nodeSel.classed("active", n => n.id === d.id)
             .classed("neighbor", n => (links.some(l => (l.source.id ?? l.source)===d.id && (l.target.id ?? l.target)===n.id)) || 
                                       (links.some(l => (l.target.id ?? l.target)===d.id && (l.source.id ?? l.source)===n.id)));
      linkSel.classed("active", l => (l.source.id ?? l.source) === d.id || (l.target.id ?? l.target) === d.id);
    }
    function clearHighlight() {
      svg.classed("highlight", false);
      nodeSel.classed("active", false).classed("neighbor", false);
      linkSel.classed("active", false);
    }

    function applyFilters() {
      const q = searchInput.value.trim().toLowerCase();
      const role = filterRole.value;

      nodeSel.style("display", d => {
        const roleOk = (role === "all") || d.role === role;
        const textOk = !q || d.id.toLowerCase().includes(q);
        return (roleOk && textOk) ? null : "none";
      });

      const visibleIds = new Set();
      nodeSel.each(function(d){ if (this.style.display !== "none") visibleIds.add(d.id); });
      linkSel.style("display", l => (visibleIds.has(l.source.id ?? l.source) && visibleIds.has(l.target.id ?? l.target)) ? null : "none");
    }

    function fitToView(zoom, padding=60) {
      const data = nodeSel.nodes().map(n => n.__data__);
      if (!data.length) return;
      const xs = data.map(n => n.x), ys = data.map(n => n.y);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const boxWidth = Math.max(1, maxX - minX);
      const boxHeight = Math.max(1, maxY - minY);
      const midX = (minX + maxX) / 2;
      const midY = (minY + maxY) / 2;

      const rect = svg.node().getBoundingClientRect();
      const scale = Math.max(0.25, Math.min(3, Math.min((rect.width - padding) / boxWidth, (rect.height - padding) / boxHeight)));
      const transform = d3.zoomIdentity.translate(rect.width/2, rect.height/2).scale(scale).translate(-midX, -midY);
      svg.transition().duration(600).call(zoom.transform, transform);
    }
  </script>
</body>
</html>
